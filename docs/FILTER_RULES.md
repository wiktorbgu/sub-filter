[EN](FILTER_RULES_en.md) / [RU](FILTER_RULES_ru.md)  / [ZH](FILTER_RULES_zh.md) 

# Документация для `rules.yaml`

Файл `rules.yaml` — это как **список правил** для программы `sub-filter`. Эти правила помогают программе решить, **какие прокси-ссылки хорошие** (и их нужно оставить), а **какие плохие** (и их нужно удалить).

Представь, что `sub-filter` — это как **фильтр для воды**, но вместо воды, он фильтрует **подписки на прокси-сервера**. `rules.yaml` — это **инструкция для фильтра**, говорящая ему, какие характеристики должны быть у "чистой воды" (хороших прокси-ссылок).

### Структура файла

Файл `rules.yaml` разделён на **разделы**. Каждый раздел отвечает за **один тип прокси**. Вот основные типы:

*   `vless`
*   `vmess`
*   `trojan`
*   `hysteria2`
*   `ss` (Shadowsocks)

В каждом разделе могут быть **четыре вида правил**:

1.  **`required_params`** (Обязательные параметры)
    *   Это список **параметров**, которые **обязательно** должны быть в ссылке этого типа.
    *   Если какого-то обязательного параметра **нет**, ссылка считается **плохой** и удаляется.
    *   Пример: Для `vless` часто обязательны `encryption` (шифрование) и `sni`.
2.  **`allowed_values`** (Разрешённые значения)
    *   Это список **разрешённых** значений для **определённых параметров**.
    *   Если значение параметра **не в списке разрешённых**, ссылка считается **плохой** и удаляется.
    *   Пример: Для параметра `security` в `vless` разрешены только `tls` и `reality`. Любое другое значение, например `none`, запрещено.
3.  **`forbidden_values`** (Запрещённые значения)
    *   Это список **запрещённых** значений для **определённых параметров**.
    *   Если значение параметра **в списке запрещённых**, ссылка считается **плохой** и удаляется.
    *   Пример: Раньше `security: ["none"]` означало, что `security` не может быть `none`. Теперь это правило может быть частью `conditional`.
4.  **`conditional`** (Условные правила)
    *   Это **сложные правила**, которые действуют **только при определённых условиях**.
    *   У них есть часть `when` ("когда"). Если **все условия** в `when` выполняются, тогда применяются остальные части правила.
    *   Примеры:
        *   `when: { security: "reality" } require: ["pbk"]` — **Когда** `security` равно `reality`, **требовать**, чтобы был параметр `pbk`.
        *   `when: { type: "grpc" } require: ["serviceName"]` — **Когда** `type` (тип подключения) равно `grpc`, **требовать**, чтобы был параметр `serviceName`.
        *   `when: { type: { not: "ws" } } forbidden_values: { security: ["none"] }` — **Когда** `type` **НЕ равно** `ws`, **запрещать**, чтобы `security` было `none`. (Это новое правило, которое позволяет `security=none` только для `type=ws`).

### Пример из файла

```yaml
vless:
  required_params:
    - encryption
    - sni
  allowed_values:
    security: ["tls", "reality"]
    flow:
      - "xtls-rprx-vision"
      - "xtls-rprx-vision-udp443"
  conditional:
    - when: { security: "reality" }
      require: ["pbk"]
    - when: { type: "grpc" }
      require: ["serviceName"]
    - when: { type: { not: "ws" } }
      forbidden_values: { security: ["none"] }
```

**Объяснение:**

1.  **Для всех `vless` ссылок:**
    *   Обязательно должны быть параметры `encryption` и `sni`.
    *   Параметр `security` может быть только `tls` или `reality`.
    *   Параметр `flow` может быть только `xtls-rprx-vision` или `xtls-rprx-vision-udp443`.
2.  **Дополнительно:**
    *   Если `security` равно `reality`, то **обязательно** должен быть параметр `pbk`.
    *   Если `type` равно `grpc`, то **обязательно** должен быть параметр `serviceName`.
    *   **Если `type` НЕ равно `ws`**, то **запрещено**, чтобы `security` было `none`.

---